import uuid
import time
import smtplib
import threading
import os
from typing import List, Dict, Any
from datetime import datetime, timedelta
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header
import socket

from celery import shared_task, current_task
from django.conf import settings
from django.core.mail import EmailMultiAlternatives
from django.utils import timezone
from django.db import transaction
from django.core.cache import cache

from .models import Campaign, EmailTracking, CampaignRecipient
from apps.mailer.models import Contact
from apps.mail_templates.models import EmailTemplate
from apps.emails.models import SenderEmail

# Centralized queue names with safe fallbacks.
CAMPAIGN_QUEUE = getattr(settings, 'CAMPAIGN_QUEUE', 'default')
EMAIL_QUEUE = getattr(settings, 'EMAIL_QUEUE', 'default')

import smtplib
import threading
from queue import Queue

class SMTPConnectionPool:
    def __init__(self, host="localhost", port=25, max_connections=10):
        self.host = host
        self.port = port
        self.pool = Queue(max_connections)
        self.lock = threading.Lock()
        self.max_connections = max_connections
        self.created = 0

    def get_connection(self):
        try:
            return self.pool.get_nowait()
        except:
            with self.lock:
                if self.created < self.max_connections:
                    conn = smtplib.SMTP(self.host, self.port, timeout=30)
                    conn.ehlo()
                    self.created += 1
                    return conn
            return self.pool.get()

    def release(self, conn):
        try:
            self.pool.put_nowait(conn)
        except:
            try:
                conn.quit()
            except:
                pass

smtp_pool = SMTPConnectionPool(
    host="localhost",
    port=25,
    max_connections=20
)

# Добавляем импорт для DKIM подписи
try:
    import dkim
    DKIM_AVAILABLE = True
except ImportError:
    DKIM_AVAILABLE = False
    if getattr(settings, 'EMAIL_DEBUG', False):
        print("Warning: dkim library not available. DKIM signing will be disabled.")


PROGRESS_CACHE_TIMEOUT = 60 * 60  # 1 hour


def _smtp_status_code(exc) -> int | None:
    """Extract SMTP status code if present (e.g. 421, 450, 550)."""
    code = getattr(exc, "smtp_code", None)
    if code is None and getattr(exc, "args", None):
        try:
            if isinstance(exc.args[0], int):
                code = exc.args[0]
        except Exception:
            code = None
    try:
        return int(code) if code is not None else None
    except Exception:
        return None


def _is_temporary_smtp_error(exc) -> bool:
    """4xx SMTP responses are temporary; also treat disconnects/timeouts as temporary."""
    code = _smtp_status_code(exc)
    if code is not None and 400 <= code < 500:
        return True
    # Some errors don't carry a code but are transient in practice.
    transient_types = (
        smtplib.SMTPServerDisconnected,
        smtplib.SMTPConnectError,
        smtplib.SMTPHeloError,
        smtplib.SMTPRecipientsRefused,
    )
    if isinstance(exc, transient_types):
        # SMTPRecipientsRefused can be permanent too, but if it has 4xx we already returned True above.
        # Without code, be conservative and retry a few times.
        return True
    return False


def _retry_backoff(retries: int, base: int = 30, cap: int = 900) -> int:
    """Exponential backoff: 30s, 60s, 120s... capped."""
    try:
        r = max(int(retries), 0)
    except Exception:
        r = 0
    return min(cap, base * (2 ** r))


def maybe_finalize_campaign(campaign_id: str) -> None:
    """Finalize campaign when all recipients are processed (is_sent=True)."""
    lock_key = f"campaign_finalize_lock_{campaign_id}"
    # prevent thundering herd
    if not cache.add(lock_key, 1, 30):
        return
    try:
        from apps.mailer.models import Contact as MailerContact

        total = CampaignRecipient.objects.filter(
            campaign_id=campaign_id,
            contact__status=MailerContact.VALID
        ).count()
        if total <= 0:
            return

        sent = CampaignRecipient.objects.filter(
            campaign_id=campaign_id,
            is_sent=True,
            contact__status=MailerContact.VALID
        ).count()

        done = sent >= total
        update_campaign_progress_cache(
            campaign_id,
            total=total,
            sent=sent,
            lock=done,
            force=True
        )

        if done:
            Campaign.objects.filter(id=campaign_id).update(
                status=Campaign.STATUS_SENT,
                sent_at=timezone.now(),
                celery_task_id=None,
                failure_reason=None
            )
            cache.delete(f"campaign_{campaign_id}")
    finally:
        cache.delete(lock_key)

def update_campaign_progress_cache(campaign_id, *, total=None, sent=None, delta_sent=0, lock: bool = False, force: bool = False):
    """
    Обновляет кэш прогресса кампании для быстрого отображения на фронте.
    """
    cache_key = f'campaign_progress_{campaign_id}'
    progress = cache.get(cache_key) or {'total': 0, 'sent': 0, 'locked': False}

    # Если кэш зафиксирован (кампания уже завершена), не меняем значения,
    # кроме случая явного принудительного обновления.
    if progress.get('locked') and not force:
        return progress
    
    if total is not None:
        progress['total'] = max(int(total), 0)
    if sent is not None:
        progress['sent'] = max(int(sent), 0)
    if delta_sent:
        progress['sent'] = max(progress.get('sent', 0) + int(delta_sent), 0)

    if lock:
        progress['locked'] = True
    
    cache.set(cache_key, progress, PROGRESS_CACHE_TIMEOUT)
    return progress


def mark_contact_as_invalid(contact, reason: str = ''):
    """
    Переводит контакт в статус INVALID, чтобы больше не пытаться отправлять на него письма.
    """
    try:
        from apps.mailer.models import Contact as MailerContact
        if contact.status != MailerContact.INVALID:
            contact.status = MailerContact.INVALID
            contact.save(update_fields=['status'])
            if getattr(settings, 'EMAIL_DEBUG', False):
                print(f"Contact {contact.email} marked as INVALID. Reason: {reason}")
    
except Exception as exc:
    print(f"Error sending email to {contact.email if 'contact' in locals() else 'unknown'}: {exc}")

    if smtp_connection:
        try:
            smtp_pool.return_connection(smtp_connection)
        except Exception:
            pass

    # Последняя попытка — фиксируем окончательный fail (без инвалидирования по умолчанию)
    if self.request.retries >= 4:
        record_failure(str(exc), mark_invalid=False)
        return {
            "success": False,
            "final_failed": True,
            "reason": str(exc),
            "email": contact.email if "contact" in locals() else None,
        }

    backoff = _retry_backoff(self.request.retries)
    raise self.retry(exc=exc, countdown=backoff, max_retries=5)


@shared_task(bind=True, time_limit=300, soft_time_limit=240)
def auto_fix_stuck_campaigns(self):
    """
    Автоматическое исправление зависших кампаний.
    Запускается каждые 5 минут через Celery Beat.
    """
    from django.utils import timezone
    from datetime import timedelta
    from django.core.cache import cache
    from celery.result import AsyncResult
    from apps.mailer.models import Contact as MailerContact
    
    print(f"[{timezone.now()}] Starting automatic fix of stuck campaigns...")
    
    # Таймаут для зависших кампаний (15 минут)
    timeout_minutes = 15
    cutoff_time = timezone.now() - timedelta(minutes=timeout_minutes)
    
    # Находим зависшие кампании
    stuck_campaigns = Campaign.objects.filter(
        status=Campaign.STATUS_SENDING,
        updated_at__lt=cutoff_time
    )
    
    fixed_count = 0
    for campaign in stuck_campaigns:
        try:
            if campaign.status == Campaign.STATUS_SENT:
                continue
            print(f"Fixing stuck campaign: {campaign.name} (ID: {campaign.id})")
            
            # Проверяем task_id
            if campaign.celery_task_id:
                task_result = AsyncResult(campaign.celery_task_id)
                
                if task_result.state in ['SUCCESS', 'FAILURE', 'REVOKED']:
                    print(f"  Task completed with state: {task_result.state}")
                elif task_result.state == 'PENDING':
                    print(f"  Task stuck in PENDING, revoking...")
                    task_result.revoke(terminate=True)
                else:
                    print(f"  Task in state: {task_result.state}")
            
            # Проверяем, сколько писем было отправлено
            sent_count = CampaignRecipient.objects.filter(
                campaign=campaign, 
                is_sent=True,
                contact__status=MailerContact.VALID
            ).count()
            
            total_count = CampaignRecipient.objects.filter(
                campaign=campaign,
                contact__status=MailerContact.VALID
            ).count()
            
            print(f"  Statistics: {sent_count}/{total_count} emails sent")
            
            # Определяем финальный статус
            if sent_count > 0:
                if sent_count == total_count:
                    campaign.status = Campaign.STATUS_SENT
                    print(f"  Campaign marked as SENT ({sent_count}/{total_count} emails sent)")
                else:
                    campaign.status = Campaign.STATUS_SENT  # Помечаем как отправленную, если хоть что-то отправилось
                    print(f"  Campaign marked as SENT ({sent_count}/{total_count} emails sent)")
            else:
                # Если ничего не отправилось, проверяем, есть ли контакты
                total_contacts = 0
                for contact_list in campaign.contact_lists.all():
                    total_contacts += contact_list.contacts.count()
                
                if total_contacts == 0:
                    campaign.status = Campaign.STATUS_FAILED
                    print(f"  Campaign marked as FAILED (no contacts)")
                else:
                    campaign.status = Campaign.STATUS_FAILED
                    print(f"  Campaign marked as FAILED (no emails sent despite {total_contacts} contacts)")
            
            # Очищаем task_id
            campaign.celery_task_id = None
            campaign.sent_at = timezone.now()
            campaign.save(update_fields=['status', 'celery_task_id', 'sent_at'])
            
            # Очищаем кэш
            cache.delete(f'campaign_progress_{campaign.id}')
            cache.delete(f'campaign_{campaign.id}')
            
            fixed_count += 1
            
        except Exception as e:
            print(f"Error fixing campaign {campaign.id}: {e}")
            continue
    
    print(f"[{timezone.now()}] Auto-fix completed: {fixed_count} campaigns fixed")
    return {
        'fixed_campaigns': fixed_count,
        'timestamp': timezone.now().isoformat()
    }


@shared_task(bind=True, time_limit=300, soft_time_limit=240)
def cleanup_stuck_campaigns(self):
    """
    Автоматическая очистка зависших кампаний.
    Запускается каждые 10 минут через Celery Beat.
    """
    from django.utils import timezone
    from datetime import timedelta
    from django.core.cache import cache
    from apps.mailer.models import Contact as MailerContact
    
    print(f"[{timezone.now()}] Starting automatic cleanup of stuck campaigns...")
    
    # Таймаут для зависших кампаний (30 минут)
    timeout_minutes = 30
    cutoff_time = timezone.now() - timedelta(minutes=timeout_minutes)
    
    # Находим зависшие кампании
    stuck_campaigns = Campaign.objects.filter(
        status=Campaign.STATUS_SENDING,
        updated_at__lt=cutoff_time
    )
    
    cleaned_count = 0
    for campaign in stuck_campaigns:
        try:
            if campaign.status == Campaign.STATUS_SENT:
                continue
            print(f"Cleaning up stuck campaign: {campaign.name} (ID: {campaign.id})")
            
            # Проверяем, сколько писем было отправлено
            sent_count = CampaignRecipient.objects.filter(
                campaign=campaign, 
                is_sent=True,
                contact__status=MailerContact.VALID
            ).count()
            
            total_count = CampaignRecipient.objects.filter(
                campaign=campaign,
                contact__status=MailerContact.VALID
            ).count()
            
            # Определяем финальный статус
            if sent_count > 0:
                if sent_count == total_count:
                    campaign.status = Campaign.STATUS_SENT
                    print(f"  Campaign marked as SENT ({sent_count}/{total_count} emails sent)")
                else:
                    campaign.status = Campaign.STATUS_SENT
                    print(f"  Campaign marked as SENT ({sent_count}/{total_count} emails sent)")
            else:
                campaign.status = Campaign.STATUS_DRAFT
                print(f"  Campaign reset to DRAFT (no emails sent)")
            
            # Очищаем task_id
            campaign.celery_task_id = None
            campaign.save(update_fields=['status', 'celery_task_id'])
            
            # Очищаем кэш
            cache.delete(f'campaign_progress_{campaign.id}')
            
            cleaned_count += 1
            
        except Exception as e:
            print(f"Error cleaning up campaign {campaign.id}: {e}")
            continue
    
    print(f"[{timezone.now()}] Cleanup completed: {cleaned_count} campaigns cleaned")
    return {
        'cleaned_campaigns': cleaned_count,
        'timestamp': timezone.now().isoformat()
    }


@shared_task(bind=True, time_limit=300, soft_time_limit=240)
def monitor_campaign_progress(self):
    """
    Мониторинг прогресса кампаний и автоматическое исправление проблем.
    Запускается каждые 5 минут через Celery Beat.
    """
    from django.utils import timezone
    from datetime import timedelta
    from django.core.cache import cache
    from celery.result import AsyncResult
    from apps.mailer.models import Contact as MailerContact
    
    print(f"[{timezone.now()}] Starting campaign progress monitoring...")
    
    # Проверяем кампании в статусе "sending"
    sending_campaigns = Campaign.objects.filter(status=Campaign.STATUS_SENDING)
    
    monitored_count = 0
    for campaign in sending_campaigns:
        try:
            monitored_count += 1
            if campaign.status == Campaign.STATUS_SENT:
                continue
            
            # Проверяем task_id. Не помечаем как failed, если есть отправленные письма
            if not campaign.celery_task_id:
                print(f"Campaign {campaign.id} has no task_id, evaluating delivery stats before marking status")
                sent_count = CampaignRecipient.objects.filter(
                    campaign=campaign,
                    is_sent=True,
                    contact__status=MailerContact.VALID
                ).count()
                total_count = CampaignRecipient.objects.filter(
                    campaign=campaign,
                    contact__status=MailerContact.VALID
                ).count()
                if sent_count > 0:
                    campaign.status = Campaign.STATUS_SENT
                    campaign.save(update_fields=['status'])
                else:
                    campaign.status = Campaign.STATUS_FAILED
                    campaign.failure_reason = campaign.failure_reason or 'celery_task_id missing and no emails sent'
                    campaign.save(update_fields=['status', 'failure_reason'])
                continue
            
            # Проверяем статус задачи Celery
            task_result = AsyncResult(campaign.celery_task_id)
            
            if task_result.state in ['SUCCESS', 'FAILURE', 'REVOKED']:
                # Задача завершена, но статус кампании не обновлен
                print(f"Campaign {campaign.id} task completed with state: {task_result.state}")
                
                # Проверяем количество отправленных писем
                sent_count = CampaignRecipient.objects.filter(
                    campaign=campaign, 
                    is_sent=True,
                    contact__status=MailerContact.VALID
                ).count()
        
                total_count = CampaignRecipient.objects.filter(
                    campaign=campaign,
                    contact__status=MailerContact.VALID
                ).count()
                
                if sent_count > 0:
                    # Если хоть что-то доставлено/отправлено — это SENT, не FAILED
                    # Дополнительно проверяем доставку >= 70% от отправленных
                    delivered_count = EmailTracking.objects.filter(campaign=campaign, delivered_at__isnull=False).count()
                    delivery_ratio = (delivered_count / sent_count) if sent_count else 0
                    campaign.status = Campaign.STATUS_SENT
                    print(f"  Campaign marked as SENT ({sent_count}/{total_count}), delivered {delivered_count}/{sent_count} ({delivery_ratio:.0%})")
                else:
                    campaign.status = Campaign.STATUS_FAILED
                    campaign.failure_reason = campaign.failure_reason or 'no emails sent'
                    print(f"  Campaign marked as FAILED (no emails sent)")
                
                campaign.save(update_fields=['status', 'failure_reason'])
            
            elif task_result.state == 'PENDING':
                # Задача в очереди слишком долго
                task_age = timezone.now() - campaign.updated_at
                if task_age > timedelta(minutes=15):
                    print(f"Campaign {campaign.id} task stuck in PENDING for {task_age}")
                    # Можно добавить логику для перезапуска задачи
            
        except Exception as e:
            print(f"Error monitoring campaign {campaign.id}: {e}")
            continue
    
    print(f"[{timezone.now()}] Monitoring completed: {monitored_count} campaigns checked")
    return {
        'monitored_campaigns': monitored_count,
        'timestamp': timezone.now().isoformat()
    }


@shared_task(bind=True, time_limit=300, soft_time_limit=240)
def cleanup_smtp_connections(self):
    """
    Очистка SMTP соединений и проверка их состояния.
    Запускается каждые 10 минут через Celery Beat.
    """
    from django.core.cache import cache
    
    print(f"[{timezone.now()}] Starting SMTP connections cleanup...")
    
    try:
        # Очищаем старые SMTP соединения из кэша
        smtp_keys = cache.keys('smtp_connection_*')
        cleaned_connections = 0
        
        for key in smtp_keys:
            connection_data = cache.get(key)
            if connection_data:
                # Проверяем возраст соединения (старше 30 минут)
                from django.utils import timezone
                from datetime import timedelta
                
                if 'created_at' in connection_data:
                    created_at = connection_data['created_at']
                    if isinstance(created_at, str):
                        from datetime import datetime
                        created_at = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                    
                    if timezone.now() - created_at > timedelta(minutes=30):
                        cache.delete(key)
                        cleaned_connections += 1
        
        print(f"[{timezone.now()}] SMTP cleanup completed: {cleaned_connections} connections cleaned")
        
        return {
            'cleaned_connections': cleaned_connections,
            'timestamp': timezone.now().isoformat()
        }
        
    except Exception as e:
        print(f"Error during SMTP cleanup: {e}")
        return {
            'error': str(e),
            'timestamp': timezone.now().isoformat()
        } 
